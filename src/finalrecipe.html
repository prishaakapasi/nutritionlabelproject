<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="finalrecipe.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title> About </title>
</head>
<body>
  <nav class="navbar">
    <ul>
      <li><a href="index.html">Home</a></li>
      <li><a href="about.html">About</a></li>
      <li><a href="tutorial.html">Tutorial</a></li>
      <li><a href="setuprecipe.html">Create</a></li>
      <li><a href="library.html">Library</a></li>
    </ul>
  </nav>
  
  <div class="recipe-container">
    <div id="loadingMessage" class="loading">
      Loading your community recipe...
    </div>
    
    <div id="errorMessage" class="error" style="display: none;">
      Unable to load recipe. Please go back and complete the setup.
    </div>
    
    <div id="recipeContent" style="display: none;">
      <div class="recipe-header">
        <h1>Your Community Governance Recipe</h1>
        <p class="community-type" id="communityType"></p>
      </div>
      
      <div id="modulesContent"></div>
      
      <div class="action-buttons">
        <button class="btn-download" onclick="downloadRecipe()">Download as Text</button>
        <a href="setuprecipe.html" class="btn-edit">Edit Recipe</a>
      </div>
    </div>
  </div>

  <script type="module">
    import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

    const supabaseUrl = "https://sewbsumjjlpsbadgwgfk.supabase.co";
    const supabaseKey = "sb_publishable_wSb8KHh3lvlLMMCxSTLQ-Q_bYqvk77x";
    const supabase = createClient(supabaseUrl, supabaseKey);

    const communityId = localStorage.getItem("communityId");

    // Module column mappings - these are columns in the communities table
    const moduleColumnMappings = {
      "Infrastructure": "infrastructure_data",
      "Admin": "admin_data",
      "Membership": "membership_data",
      "Rules": "rules_data",
      "Federation": "federation_data",
      "Data/Privacy": "dataprivacy_data",
      "Community Processes": "communityprocesses_data",
      "Legal Compliance": "legalcompliance_data"
    };

    async function loadRecipe() {
      console.log("Starting to load recipe...");
      console.log("Community ID:", communityId);
      
      if (!communityId) {
        console.error("No community ID found!");
        showError();
        return;
      }

      try {
        // Load community data
        const { data: community, error: communityError } = await supabase
          .from("communities")
          .select("*")
          .eq("id", communityId)
          .single();

        console.log("Community data:", community);
        console.log("Community error:", communityError);

        if (communityError || !community) {
          console.error("Error loading community:", communityError);
          showError();
          return;
        }

        // Display community type
        document.getElementById("communityType").textContent = 
          `Community Type: ${community.type || 'Not specified'}`;

        const modulesContent = document.getElementById("modulesContent");
        modulesContent.innerHTML = "";

        // Get selected modules
        const selectedModules = community.selected_modules || [];
        console.log("Selected modules:", selectedModules);
        
        if (selectedModules.length === 0) {
          modulesContent.innerHTML = "<p>No modules selected.</p>";
          document.getElementById("loadingMessage").style.display = "none";
          document.getElementById("recipeContent").style.display = "block";
          return;
        }

        // Load data for each selected module
        for (const moduleName of selectedModules) {
          console.log("Processing module:", moduleName);
          const columnName = moduleColumnMappings[moduleName];
          console.log("Column name:", columnName);
          
          if (columnName && community[columnName]) {
            // Get data from the column in the community record
            const moduleData = community[columnName];
            console.log(`Data for ${moduleName}:`, moduleData);

            // Only display if there's actual data
            if (moduleData && typeof moduleData === 'object') {
              // Check if the object has any non-empty values (recursively)
              const hasData = hasActualData(moduleData);
              
              if (hasData) {
                displayModuleSection(moduleName, moduleData);
              } else {
                console.log(`Skipping ${moduleName} - no actual data`);
              }
            } else {
              console.log(`Skipping ${moduleName} - empty or invalid data`);
            }
          } else {
            console.log(`Skipping ${moduleName} - no column mapping or no data in column`);
          }
        }

        // Show the recipe
        document.getElementById("loadingMessage").style.display = "none";
        document.getElementById("recipeContent").style.display = "block";

      } catch (error) {
        console.error("Error loading recipe:", error);
        showError();
      }
    }

    function hasActualData(obj) {
      // Check if an object or any of its nested values contain actual data
      if (obj === null || obj === undefined || obj === '') {
        return false;
      }
      
      // For arrays, check if any element has data
      if (Array.isArray(obj)) {
        if (obj.length === 0) return false;
        return obj.some(item => hasActualData(item));
      }
      
      // For objects, recursively check all values
      if (typeof obj === 'object') {
        const values = Object.values(obj);
        if (values.length === 0) return false;
        return values.some(val => hasActualData(val));
      }
      
      // Primitive values (strings, numbers, booleans)
      return true;
    }

    function displayModuleSection(moduleName, data) {
      const modulesContent = document.getElementById("modulesContent");
      
      const section = document.createElement("div");
      section.className = "module-section";
      
      const title = document.createElement("h2");
      title.textContent = moduleName;
      section.appendChild(title);
      
      const content = document.createElement("div");
      content.className = "module-content";
      
      if (!data || (typeof data === 'object' && Object.keys(data).length === 0)) {
        content.innerHTML = "<p><em>No data entered for this module yet.</em></p>";
        section.appendChild(content);
        modulesContent.appendChild(section);
        return;
      }
      
      let hasAnyData = false;
      
      // Display all the data fields from this module
      for (const [key, value] of Object.entries(data)) {
        // Skip if value is null, undefined, or empty string
        if (value === null || value === undefined || value === '') {
          continue;
        }
        
        // Skip empty arrays
        if (Array.isArray(value) && value.length === 0) {
          continue;
        }
        
        // For objects, check if they have any non-empty values
        if (typeof value === 'object' && !Array.isArray(value)) {
          const hasNonEmptyValues = Object.values(value).some(v => 
            v !== null && v !== undefined && v !== ''
          );
          if (!hasNonEmptyValues) {
            continue;
          }
        }
        
        hasAnyData = true;
        
        const dataItem = document.createElement("div");
        dataItem.className = "data-item";
        
        const label = document.createElement("div");
        label.className = "data-label";
        label.textContent = formatFieldName(key) + ":";
        
        const valueDiv = document.createElement("div");
        valueDiv.className = "data-value";
        
        // Special handling for channels array
        if (key === 'channels' && Array.isArray(value)) {
          const channelLinks = value.map(ch => {
            if (ch.url) {
              return `<a href="${ch.url}" target="_blank">${ch.platform || 'Link'}</a>`;
            }
            return '';
          }).filter(Boolean).join(', ');
          valueDiv.innerHTML = channelLinks || formatValue(value);
        } 
        // Special handling for nested objects like dmcaAgent
        else if (typeof value === 'object' && !Array.isArray(value)) {
          const nestedContent = document.createElement("div");
          nestedContent.style.marginLeft = "15px";
          
          for (const [nestedKey, nestedValue] of Object.entries(value)) {
            if (nestedValue !== null && nestedValue !== undefined && nestedValue !== '') {
              const nestedItem = document.createElement("div");
              nestedItem.style.margin = "5px 0";
              nestedItem.innerHTML = `<strong>${formatFieldName(nestedKey)}:</strong> ${nestedValue}`;
              nestedContent.appendChild(nestedItem);
            }
          }
          
          valueDiv.appendChild(nestedContent);
        } 
        else {
          valueDiv.textContent = formatValue(value);
        }
        
        dataItem.appendChild(label);
        dataItem.appendChild(valueDiv);
        content.appendChild(dataItem);
      }
      
      // If no data was actually displayed, show the "no data" message
      if (!hasAnyData) {
        content.innerHTML = "<p><em>No data entered for this module yet.</em></p>";
      }
      
      section.appendChild(content);
      modulesContent.appendChild(section);
    }

    function formatFieldName(fieldName) {
  return fieldName
 
    .replace(/_/g, " ")
    .replace(/([a-z])([A-Z])/g, "$1 $2")
    // capitalize first letter of each word
    .split(" ")
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
}

    function formatValue(value) {
      // Handle null/undefined
      if (value === null || value === undefined) {
        return '';
      }
      
      // Handle arrays
      if (Array.isArray(value)) {
        // Filter out empty values
        const filtered = value.filter(v => v !== null && v !== undefined && v !== '');
        if (filtered.length === 0) return '';
        
        // If array contains objects, try to format them nicely
        if (filtered.length > 0 && typeof filtered[0] === 'object') {
          return filtered.map(item => {
            if (item.url && item.platform) {
              return `${item.platform}: ${item.url}`;
            }
            return JSON.stringify(item);
          }).join('\n');
        }
        
        return filtered.join(', ');
      }
      
      // Handle objects (but not arrays)
      if (typeof value === 'object') {
        try {
          const stringified = JSON.stringify(value, null, 2);
          // Don't show empty objects
          if (stringified === '{}' || stringified === '[]') return '';
          return stringified;
        } catch (e) {
          return String(value);
        }
      }
      
      // Handle strings and primitives
      return String(value);
    }

    function showError() {
      document.getElementById("loadingMessage").style.display = "none";
      document.getElementById("errorMessage").style.display = "block";
    }

    // Make downloadRecipe available globally
    window.downloadRecipe = function() {
      const recipeContent = document.getElementById("recipeContent");
      const text = recipeContent.innerText;
      
      const blob = new Blob([text], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'community-recipe.txt';
      a.click();
      URL.revokeObjectURL(url);
    };

    // Load recipe when page loads
    loadRecipe();
  </script>
</body>
</html>